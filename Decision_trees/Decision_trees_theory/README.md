_Дерево решений_ — эффективный инструмент интеллектуального анализа данных и предсказательной аналитики. Он помогает в решении задач по классификации и регрессии.
Дерево решений относятся к алгоритмам _обучения с учителем (Supervised learning)_.
Дерево представляет собой иерархическую древовидную структуру, состоящую из правила вида «Если …, то ...». За счет обучающего множества правила генерируются автоматически в процессе обучения.
В отличие от многих других методов, дерево решений как аналитическая модель проще, потому что правила генерируются на естественном языке.
Правила генерируются за счет обобщения множества отдельных наблюдений (обучающих примеров), описывающих предметную область. Поэтому их называют индуктивными правилами, а сам процесс обучения — индукцией деревьев решений.

В обучающем множестве для примеров должно быть задано целевое значение, так как деревья решений — модели, создаваемые на основе обучения с учителем. По типу переменной выделяют два типа деревьев:

_Дерево классификации_ — когда целевая переменная дискретная;

_Дерево регрессии_ — когда целевая переменная непрерывная.

Развитие инструмента началось в 1950-х годах. Тогда были предложены основные идеи в области исследований моделирования человеческого поведения с помощью компьютерных систем.

Метод имеет ряд существенных плюсов.

1)	Прост в понимании и интерпретации.
2)	Не требует специальной подготовки данных (нормализации данных, добавления фиктивных переменных, удаления пропущенных данных).
3)	Способен работать как с категориальными, так и с интервальными переменными.
4)	Использует модель «белого ящика», то есть если определённая ситуация наблюдается в модели, то её можно объяснить при помощи булевой логики (описание, что такое _булевая логика_, дано ниже).
5)	Позволяет оценить модель при помощи статистических тестов. Это даёт возможность оценить надёжность модели.
6)	Метод хорошо работает даже в том случае, если были нарушены первоначальные предположения, включённые в модель.
7)	Позволяет работать с большим объёмом информации без специальных подготовительных процедур.

К недостаткам метода относятся.
1)	Проблема получения оптимального дерева решений является NP-полной задачей (описание, что такое _NP-полная задача_, дано ниже), с точки зрения некоторых аспектов оптимальности даже для простых задач. Таким образом, практическое применение алгоритма деревьев решений основано на эвристических алгоритмах, таких как алгоритм «жадности» (описание, что такое «жадный» алгоритм, дано ниже), где единственно оптимальное решение выбирается локально в каждом узле. Такие алгоритмы не могут обеспечить оптимальность всего дерева в целом.
2)	В процессе построения дерева решений могут создаваться слишком сложные конструкции, которые недостаточно полно представляют данные. Данную проблему называют переобучением. Для того, чтобы её избежать, необходимо использовать метод «регулирования глубины дерева» (об этом ниже).
3)	Существуют понятия, которые сложно понять из модели, так как модель описывает их сложным путём. Данное явление может быть вызвано проблемами XOR, чётности или мультиплексарности. В этом случае мы имеем дело с непомерно большими деревьями. Существует несколько подходов решения данной проблемы, например, попытка изменить репрезентацию концепта в модели (составление новых суждений), или использование алгоритмов, которые более полно описывают и репрезентируют концепт (например, метод статистических отношений, индуктивная логика программирования).
4)	Для данных, которые включают категориальные переменные с большим набором уровней (закрытий), больший информационный вес присваивается тем признакам, которые имеют большее количество уровней.

Один из вопросов, который возникает в алгоритме дерева решений — это оптимальный размер конечного дерева.
Так, небольшое дерево может не охватить ту или иную важную информацию о выборочном пространстве.
Тем не менее, трудно сказать, когда алгоритм должен остановиться, потому что невозможно спрогнозировать, добавление какого узла позволит значительно уменьшить ошибку.
Эта проблема известна как «эффект горизонта». Тем не менее, общая стратегия ограничения дерева сохраняется, то есть удаление узлов реализуется в случае, если они не дают дополнительной информации.

_Регулирование глубины дерева_ — это техника, которая позволяет уменьшать размер дерева решений, удаляя участки дерева, которые имеют маленький вес.
Регулирование глубины дерева должно уменьшить размер обучающей модели дерева без уменьшения точности её прогноза или с помощью перекрестной проверки.
Есть много методов регулирования глубины дерева, которые отличаются измерением оптимизации производительности.
Сокращение дерева может осуществляться сверху вниз или снизу вверх.
Сверху вниз — обрезка начинается с корня, снизу вверх — сокращается число листьев дерева. Один из простейших методов регулирования — уменьшение ошибки ограничения дерева.
Начиная с листьев, каждый узел заменяется на самый популярный класс. Если изменение не влияет на точность предсказания, то оно сохраняется.


#### Булевая логика
Булева логика - это тип компьютерных наук, первоначально разработанный математиком Джорджем Булем в середине 1800-х годов.
По своей сути булева логика опирается на некоторые очень простые операторы, такие как AND, OR и NOT. Эксперты добавляют операторы NAND и NOR, которые объединяют один из этих операторов с отрицательным оператором NOT.
Используя вышеупомянутые элементы, разработчики могут создавать логические элементы, которые направляют поток вычислений к различным результатам.

#### NP-полная задача
Вычислительная задача называется NP-полной (Non-deterministic Polynomial – «недетерминированные с полиномиальным временем»), если для неё не существует эффективных алгоритмов решения.
К этому классу относятся много важных практических задач — задача коммивояжёра, задача раскраски графа, задача покрытия и т.д (об этих задачах ниже).

Простые вычислительные задачи могут быть решены за полиномиальное время (класс P). Это значит, что количество итераций или время поиска решения, полиномиально зависит от числа наблюдений исходных данных.

Трудоёмкость более сложных задач экспоненциально растёт с увеличением объема данных. Алгоритмы с экспоненциальным временем считаются неэффективными.

В теории алгоритмов NP-полной является задача с ответом «да» или «нет» из класса NP, к которой можно свести любую задачу из этого класса за полиномиальное время (то есть при помощи операций, число которых не превышает некоторого полинома зависимости от размера исходных данных).

Таким образом, NP-полные задачи образуют в некотором смысле подмножество «типовых» задач в классе NP: если для какой-то из них найден «полиномиально быстрый» алгоритм решения, то и любая другая задача из класса NP может быть решена так же «быстро».

Знание, относится ли задача к классу NP-полных, достаточно важно в анализе данных, поскольку в аналитических проектах приходится иметь дело с очень большими объемами исходных данных. Поэтому необходимо планировать вычислительные ресурсы и время для решения задач анализа, и если они неприемлемо возрастают, искать альтернативные пути решения (например, выполнять декомпозицию сложной задачи на ряд простых).

#### Жадный алгоритм
Жадный алгоритм (Greedy Algorithm) — это алгоритм, который на каждом шагу делает локально наилучший выбор в надежде, что итоговое решение будет оптимальным.

Может возникнуть искушение использовать жадный алгоритм везде, где это возможно. Но на некоторых задачах это неприемлемо.
К примеру, задача о рюкзаке: вор пробрался на склад, в котором хранятся три вещи весом 10 кг, 20 кг и 30 кг и стоимостью 60, 100 и 120 денежных единиц (ДЕ) соответственно.
Вор максимум может унести 50 кг. Нужно максимизировать прибыль вора.
Если поступать здесь жадно и выбирать самую ценную вещь(то есть, 6 ДЕ за кг первой штуки, 5 ДЕ за кг второй и 4 ДА за кг третьей), то вор обязательно должен взять первую вещь, потом останется место для второй вещи, однако оптимальное решение составляет вторая и третья вещь.
Небольшой скрипт, который реализует задачу представлен в приложении.

#### Задача коммивояжёра
Задача коммивояжёра (Travelling Salesman Problem (TSP)) — одна из самых известных задач комбинаторной оптимизации, заключающаяся в поиске самого выгодного маршрута,
проходящего через указанные города хотя бы по одному разу с последующим возвратом в исходный город.
В условиях задачи указываются критерий выгодности маршрута (кратчайший, самый дешёвый, совокупный критерий и тому подобное) и соответствующие матрицы расстояний, стоимости и тому подобного.
Как правило, указывается, что маршрут должен проходить через каждый город только один раз — в таком случае выбор осуществляется среди гамильтоновых циклов.
Существует несколько частных случаев общей постановки задачи, в частности, геометрическая задача коммивояжёра
(также называемая планарной или евклидовой, когда матрица расстояний отражает расстояния между точками на плоскости),
метрическая задача коммивояжёра (когда на матрице стоимостей выполняется неравенство треугольника), симметричная и асимметричная задачи коммивояжёра.
Также существует обобщение задачи, так называемая обобщённая задача коммивояжёра.

Задача коммивояжёра относится к числу трансвычислительных: уже при относительно небольшом числе городов (>66) она не может быть решена методом перебора вариантов никакими теоретически
мыслимыми компьютерами за время, меньшее нескольких миллиардов лет.

Для решения задачи коммивояжера методом ветвей и границ необходимо выполнить следующую последовательность действий:
1 - Построение матрицы с исходными данными.
2 - Нахождение минимума по строкам.
3 - Редукция строк.
4 - Нахождение минимума по столбцам.
5 - Редукция столбцов.
6 - Вычисление оценок нулевых клеток.
7 - Редукция матрицы.
8 - Если полный путь еще не найден, переходим к пункту 2, если найден к пункту 9.
9 - Вычисление итоговой длины пути и построение маршрута.

#### Раскраска графа
Раскраска графа — теоретико-графовая конструкция, частный случай разметки графа.
При раскраске элементам графа ставятся в соответствие метки с учётом определённых ограничений; эти метки традиционно называются «цветами».
В простейшем случае такой способ окраски вершин графа, при котором любым двум смежным вершинам соответствуют разные цвета, называется раскраской вершин.
Аналогично раскраска рёбер присваивает цвет каждому ребру так, чтобы любые два смежных ребра имели разные цвета.
Наконец, раскраска областей планарного графа назначает цвет каждой области, так, что каждые две области, имеющие общую границу, не могут иметь одинаковый цвет.

Раскраска вершин — главная задача раскраски графов, все остальные задачи в этой области могут быть сведены к ней.
Например, раскраска рёбер графа — это раскраска вершин его рёберного графа, а раскраска областей планарного графа — это раскраска вершин его двойственного графа.
Тем не менее, другие проблемы раскраски графов часто ставятся и решаются в изначальной постановке.
Причина этого частично заключается в том, что это даёт лучшее представление о происходящем и более показательно, а частично из-за того, что некоторые задачи таким образом решать удобнее (например, раскраска рёбер).

Раскраска графов находит применение и во многих практических областях, а не только в теоретических задачах.
Помимо классических типов проблем, различные ограничения могут также быть наложены на граф, на способ присвоения цветов или на сами цвета.

